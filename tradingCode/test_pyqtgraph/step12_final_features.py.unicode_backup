"""
Step 12: Final features implementation
Goal: 
1. Remove background gridlines
2. Implement crosshairs and data box
3. OHLC data display at top when hovering
4. Make indicators plot properly
"""

import sys
import numpy as np
import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore, QtGui
from dataclasses import dataclass
from typing import List
import time
import datetime

def save_widget_screenshot(widget, filename):
    """Save a screenshot of the widget"""
    try:
        pixmap = widget.grab()
        success = pixmap.save(filename, 'PNG')
        print(f"Screenshot saved: {filename} (Success: {success})")
        return success
    except Exception as e:
        print(f"Error saving screenshot: {e}")
        return False

@dataclass
class OHLCBar:
    """Single OHLC bar data structure"""
    index: int
    timestamp: float
    open: float
    high: float
    low: float
    close: float
    volume: float

class FinalFeaturesDataManager:
    """Manager for OHLC data with final features"""
    
    def __init__(self, num_bars: int = 100):
        self.num_bars = num_bars
        self.generate_data()
        
    def generate_data(self):
        """Generate OHLC data for testing"""
        
        print(f"Generating final features data with {self.num_bars} bars...")
        
        # Set seed for reproducible results
        np.random.seed(3000)
        
        # Generate timestamps (1-minute bars starting from a specific date)
        start_timestamp = 1609459200  # Jan 1, 2021 00:00:00 UTC
        self.timestamps = np.arange(start_timestamp, start_timestamp + self.num_bars * 60, 60)
        
        # Generate price data with clear trends
        base_price = 200.0
        
        # Create realistic price movement
        returns = np.random.normal(0.0008, 0.025, self.num_bars)  # Slight upward bias
        log_prices = np.log(base_price) + np.cumsum(returns)
        close_prices = np.exp(log_prices)
        
        # Generate opens
        gaps = np.random.normal(0, 0.002, self.num_bars)
        open_prices = np.zeros_like(close_prices)
        open_prices[0] = base_price
        for i in range(1, self.num_bars):
            open_prices[i] = close_prices[i-1] * (1 + gaps[i])
        
        # Generate highs and lows
        high_factors = np.random.exponential(0.01, self.num_bars)
        low_factors = np.random.exponential(0.01, self.num_bars)
        
        self.highs = np.maximum(open_prices, close_prices) * (1 + high_factors)
        self.lows = np.minimum(open_prices, close_prices) * (1 - low_factors)
        self.opens = open_prices
        self.closes = close_prices
        
        # Generate volume
        base_volume = 25000
        volume_noise = np.random.lognormal(0, 0.6, self.num_bars)
        self.volumes = (base_volume * volume_noise).astype(int)
        
        print(f"Price range: ${self.lows.min():.2f} - ${self.highs.max():.2f}")
        
    def get_bar(self, index: int) -> OHLCBar:
        """Get single OHLC bar by index"""
        if 0 <= index < self.num_bars:
            return OHLCBar(
                index=index,
                timestamp=self.timestamps[index],
                open=self.opens[index],
                high=self.highs[index],
                low=self.lows[index],
                close=self.closes[index],
                volume=self.volumes[index]
            )
        raise IndexError(f"Bar index {index} out of range (0-{self.num_bars-1})")
        
    def get_bars(self, start: int = 0, end: int = None) -> List[OHLCBar]:
        """Get range of OHLC bars"""
        if end is None:
            end = self.num_bars
        return [self.get_bar(i) for i in range(start, min(end, self.num_bars))]
    
    def get_visible_price_range(self, start_idx: int, end_idx: int) -> tuple:
        """Get min/max price range for visible bars"""
        start_idx = max(0, int(start_idx))
        end_idx = min(self.num_bars, int(end_idx))
        
        if start_idx >= end_idx:
            return 0, 100
        
        visible_highs = self.highs[start_idx:end_idx]
        visible_lows = self.lows[start_idx:end_idx]
        
        if len(visible_highs) == 0 or len(visible_lows) == 0:
            return 0, 100
            
        y_min = np.min(visible_lows)
        y_max = np.max(visible_highs)
        y_padding = (y_max - y_min) * 0.05  # 5% padding
        
        return y_min - y_padding, y_max + y_padding

class FinalFeaturesChartWidget(pg.PlotWidget):
    """Chart widget with all final features implemented"""
    
    def __init__(self):
        super().__init__()
        
        # Set white background
        self.setBackground('white')
        
        # 1. REMOVE BACKGROUND GRIDLINES
        self.showGrid(x=False, y=False)  # This removes the gridlines!
        
        # Set axis labels
        self.setLabel('left', 'Price ($)', color='black', size='14pt')
        self.setLabel('right', 'Price ($)', color='black', size='14pt')
        self.setLabel('bottom', 'Time (bars)', color='black', size='14pt')
        self.setLabel('top', 'Final Features: No Grid + Crosshair + OHLC + Indicators', color='black', size='14pt')
        
        # Configure all axes for maximum visibility
        for axis_name in ['left', 'right', 'bottom', 'top']:
            self.showAxis(axis_name, True)
            axis = self.getAxis(axis_name)
            if axis:
                # Thick black axes
                axis.setPen(pg.mkPen('black', width=3))
                axis.setTextPen(pg.mkPen('black', width=2))
                axis.setStyle(showValues=True, tickLength=10)
                
                # Set appropriate dimensions
                if axis_name in ['left', 'right']:
                    axis.setWidth(100)
                else:
                    axis.setHeight(60)
                
                axis.show()
        
        # Create data manager
        self.data_manager = FinalFeaturesDataManager(100)
        
        # 2. SETUP CROSSHAIRS AND DATA BOX
        self.setup_crosshairs_and_data_box()
        
        # 3. SETUP OHLC DATA DISPLAY AT TOP
        self.setup_top_ohlc_display()
        
        # Create candlestick chart
        self.create_candlestick_chart()
        
        # 4. ADD INDICATORS
        self.add_sample_indicators()
        
        # Connect to range changes for Y-axis auto-scaling
        self.plotItem.vb.sigRangeChanged.connect(self._on_range_changed)
        
        print("Step 12: Final features chart widget created")

    def setup_crosshairs_and_data_box(self):
        """Setup crosshairs with data box showing crosshair values"""
        
        # Create thick, bright crosshairs
        self.crosshair_v = pg.InfiniteLine(
            angle=90, 
            movable=False,
            pen=pg.mkPen('red', width=3, style=QtCore.Qt.SolidLine)
        )
        self.crosshair_h = pg.InfiniteLine(
            angle=0, 
            movable=False,
            pen=pg.mkPen('red', width=3, style=QtCore.Qt.SolidLine)
        )
        
        # Add to plot with high Z-value
        self.addItem(self.crosshair_v, ignoreBounds=True)
        self.addItem(self.crosshair_h, ignoreBounds=True)
        self.crosshair_v.setZValue(1000)
        self.crosshair_h.setZValue(1000)
        
        # Create data box for crosshair values
        self.crosshair_data_box = pg.TextItem(
            text="Price: $0.00 | Time: 0",
            color='black',
            fill=pg.mkBrush(255, 255, 0, 200),  # Yellow background
            border=pg.mkPen('black', width=2),
            anchor=(0, 1)  # Bottom-left anchor
        )
        
        self.addItem(self.crosshair_data_box, ignoreBounds=True)
        self.crosshair_data_box.setZValue(1001)
        
        # Hide crosshairs initially
        self.crosshair_v.hide()
        self.crosshair_h.hide()
        self.crosshair_data_box.hide()
        
        # Use SignalProxy pattern for mouse tracking
        self.mouse_proxy = pg.SignalProxy(
            self.scene().sigMouseMoved, 
            rateLimit=60, 
            slot=self._on_mouse_moved
        )
        
        print("Crosshairs and data box setup complete")

    def setup_top_ohlc_display(self):
        """Setup OHLC data display at top of screen when hovering"""
        
        # Create OHLC display at top
        self.top_ohlc_display = pg.TextItem(
            text="Hover over chart to see OHLC data",
            color='white',
            fill=pg.mkBrush(0, 0, 100, 180),  # Dark blue background
            border=pg.mkPen('white', width=2),
            anchor=(0, 0)  # Top-left anchor
        )
        
        self.addItem(self.top_ohlc_display, ignoreBounds=True)
        self.top_ohlc_display.setZValue(2000)
        
        # Position at top-left of chart
        self.top_ohlc_display.setPos(5, 240)  # Fixed position for now
        
        print("Top OHLC display setup complete")

    def wheelEvent(self, ev):
        """Fixed wheel event: Ctrl+wheel=X-zoom, wheel=X-pan, Y=auto-fit"""
        
        # Check if Ctrl key is pressed
        modifiers = ev.modifiers()
        ctrl_pressed = modifiers & QtCore.Qt.ControlModifier
        
        # Get current X range only
        current_range = self.plotItem.vb.viewRange()
        x_range = current_range[0]
        
        if ctrl_pressed:
            # Ctrl+scroll: X-axis zoom only
            zoom_factor = 1.2 if ev.angleDelta().y() > 0 else 1/1.2
            
            # Calculate zoom center
            zoom_center_x = (x_range[0] + x_range[1]) / 2
            
            # Calculate new X range
            x_span = x_range[1] - x_range[0]
            new_x_span = x_span / zoom_factor
            
            new_x_range = [
                zoom_center_x - new_x_span/2,
                zoom_center_x + new_x_span/2
            ]
            
            # Apply X zoom only
            self.plotItem.vb.setXRange(*new_x_range, padding=0)
            
        else:
            # Regular scroll: X-axis pan only
            x_span = x_range[1] - x_range[0]
            pan_amount = x_span * 0.15
            
            # Pan left or right
            if ev.angleDelta().y() > 0:  # Wheel up - pan left
                new_x_range = [x_range[0] - pan_amount, x_range[1] - pan_amount]
            else:  # Wheel down - pan right
                new_x_range = [x_range[0] + pan_amount, x_range[1] + pan_amount]
            
            # Apply X pan only
            self.plotItem.vb.setXRange(*new_x_range, padding=0)
        
        ev.accept()

    def _on_range_changed(self):
        """Handle range changes - auto-fit Y axis to visible price data"""
        
        # Get current X range
        x_range = self.plotItem.vb.viewRange()[0]
        
        # Get price range for visible bars
        y_min, y_max = self.data_manager.get_visible_price_range(x_range[0], x_range[1])
        
        # Update Y range without triggering recursion
        self.plotItem.vb.blockSignals(True)
        self.plotItem.vb.setYRange(y_min, y_max, padding=0)
        self.plotItem.vb.blockSignals(False)

    def _on_mouse_moved(self, evt):
        """Handle mouse movement for crosshairs and OHLC display"""
        try:
            pos = evt[0]  # Get position from SignalProxy
            if self.plotItem.vb.sceneBoundingRect().contains(pos):
                mousePoint = self.plotItem.vb.mapSceneToView(pos)
                x_coord = mousePoint.x()
                y_coord = mousePoint.y()
                
                # Show crosshairs
                self.crosshair_v.setPos(x_coord)
                self.crosshair_h.setPos(y_coord)
                self.crosshair_v.show()
                self.crosshair_h.show()
                
                # Update crosshair data box
                self.update_crosshair_data_box(x_coord, y_coord)
                
                # Update top OHLC display
                self.update_top_ohlc_display(x_coord)
                
            else:
                # Hide crosshairs when mouse leaves
                self.crosshair_v.hide()
                self.crosshair_h.hide()
                self.crosshair_data_box.hide()
                
        except Exception as e:
            print(f"Error in mouse handler: {e}")

    def update_crosshair_data_box(self, x_coord: float, y_coord: float):
        """Update the crosshair data box with current values"""
        
        # Format price
        price_text = f"${y_coord:.2f}"
        
        # Format time/bar index
        bar_index = int(round(x_coord))
        time_text = f"Bar {bar_index}"
        
        # Try to get actual timestamp if available
        try:
            if 0 <= bar_index < self.data_manager.num_bars:
                timestamp = self.data_manager.timestamps[bar_index]
                dt = datetime.datetime.fromtimestamp(timestamp)
                time_text = dt.strftime('%H:%M:%S')
        except:
            pass
        
        # Update data box text
        data_text = f"Price: {price_text} | Time: {time_text}"
        self.crosshair_data_box.setText(data_text)
        
        # Position data box near crosshair
        view_range = self.plotItem.vb.viewRange()
        x_offset = (view_range[0][1] - view_range[0][0]) * 0.02
        y_offset = (view_range[1][1] - view_range[1][0]) * 0.05
        
        self.crosshair_data_box.setPos(x_coord + x_offset, y_coord - y_offset)
        self.crosshair_data_box.show()

    def update_top_ohlc_display(self, x_coord: float):
        """Update the top OHLC display when hovering"""
        
        bar_index = int(round(x_coord))
        
        try:
            if 0 <= bar_index < self.data_manager.num_bars:
                bar = self.data_manager.get_bar(bar_index)
                
                # Format timestamp
                dt = datetime.datetime.fromtimestamp(bar.timestamp)
                date_str = dt.strftime('%Y-%m-%d %H:%M:%S')
                
                # Create OHLC text
                ohlc_text = (
                    f"DT: {date_str} | "
                    f"O: ${bar.open:.2f} | "
                    f"H: ${bar.high:.2f} | "
                    f"L: ${bar.low:.2f} | "
                    f"C: ${bar.close:.2f} | "
                    f"V: {bar.volume:,}"
                )
                
                self.top_ohlc_display.setText(ohlc_text)
            else:
                self.top_ohlc_display.setText("No data available for this position")
                
        except Exception as e:
            self.top_ohlc_display.setText(f"Error: {e}")

    def create_candlestick_chart(self):
        """Create candlestick chart"""
        
        print("Rendering candlestick chart...")
        start_time = time.time()
        
        # Get all bars
        bars = self.data_manager.get_bars()
        
        # Draw each candlestick
        for bar in bars:
            self.draw_candlestick(bar)
        
        # Set initial view range
        self.setXRange(-3, len(bars) + 3)
        
        render_time = time.time() - start_time
        print(f"Chart rendered in {render_time:.3f}s with {len(bars)} candlesticks")

    def draw_candlestick(self, bar: OHLCBar):
        """Draw a single candlestick"""
        
        x = bar.index
        
        # Enhanced validation
        if not (np.isfinite(bar.open) and np.isfinite(bar.high) and 
                np.isfinite(bar.low) and np.isfinite(bar.close) and
                bar.high >= max(bar.open, bar.close) and 
                bar.low <= min(bar.open, bar.close)):
            return
        
        # Determine candle color
        is_bullish = bar.close > bar.open
        
        # 1. Draw the wick
        wick_line = pg.PlotDataItem(
            [x, x], 
            [bar.low, bar.high],
            pen=pg.mkPen('black', width=1)
        )
        self.addItem(wick_line)
        
        # 2. Draw the body
        body_top = max(bar.open, bar.close)
        body_bottom = min(bar.open, bar.close)
        body_height = body_top - body_bottom
        
        # Ensure minimum body height
        if body_height < (bar.high - bar.low) * 0.02:
            body_height = (bar.high - bar.low) * 0.02
            body_top = body_bottom + body_height
        
        body_width = 0.7
        
        # Set colors (red/green)
        if is_bullish:
            brush = pg.mkBrush('white')
            pen = pg.mkPen('green', width=1)
        else:
            brush = pg.mkBrush('red')
            pen = pg.mkPen('red', width=1)
        
        # Create candle body
        body_bar = pg.BarGraphItem(
            x=[x], 
            height=[body_height],
            width=body_width,
            y0=[body_bottom],
            brush=brush,
            pen=pen
        )
        self.addItem(body_bar)

    def add_sample_indicators(self):
        """Add sample indicators that plot properly on chart"""
        
        print("Adding sample indicators...")
        
        # Get close prices for indicator calculations
        closes = self.data_manager.closes
        x_data = np.arange(len(closes))
        
        # 1. Simple Moving Average (20-period)
        sma_20 = self.calculate_sma(closes, 20)
        sma_line = self.plot(
            x_data[19:], sma_20[19:],  # Skip NaN values
            pen=pg.mkPen('blue', width=2),
            name='SMA(20)'
        )
        
        # 2. Exponential Moving Average (12-period)
        ema_12 = self.calculate_ema(closes, 12)
        ema_line = self.plot(
            x_data[11:], ema_12[11:],  # Skip NaN values
            pen=pg.mkPen('orange', width=2),
            name='EMA(12)'
        )
        
        # 3. Bollinger Bands
        bb_upper, bb_middle, bb_lower = self.calculate_bollinger_bands(closes, 20, 2)
        
        # Plot Bollinger Bands
        bb_upper_line = self.plot(
            x_data[19:], bb_upper[19:],
            pen=pg.mkPen('gray', width=1, style=QtCore.Qt.DashLine),
            name='BB Upper'
        )
        bb_lower_line = self.plot(
            x_data[19:], bb_lower[19:],
            pen=pg.mkPen('gray', width=1, style=QtCore.Qt.DashLine),
            name='BB Lower'
        )
        
        print("Sample indicators added: SMA(20), EMA(12), Bollinger Bands")

    def calculate_sma(self, prices: np.ndarray, period: int) -> np.ndarray:
        """Calculate Simple Moving Average"""
        sma = np.full_like(prices, np.nan)
        for i in range(period - 1, len(prices)):
            sma[i] = np.mean(prices[i - period + 1:i + 1])
        return sma

    def calculate_ema(self, prices: np.ndarray, period: int) -> np.ndarray:
        """Calculate Exponential Moving Average"""
        ema = np.full_like(prices, np.nan)
        multiplier = 2 / (period + 1)
        
        # Start with SMA for first value
        ema[period - 1] = np.mean(prices[:period])
        
        # Calculate EMA for remaining values
        for i in range(period, len(prices)):
            ema[i] = (prices[i] * multiplier) + (ema[i - 1] * (1 - multiplier))
        
        return ema

    def calculate_bollinger_bands(self, prices: np.ndarray, period: int, std_dev: float) -> tuple:
        """Calculate Bollinger Bands"""
        sma = self.calculate_sma(prices, period)
        
        bb_upper = np.full_like(prices, np.nan)
        bb_lower = np.full_like(prices, np.nan)
        
        for i in range(period - 1, len(prices)):
            rolling_std = np.std(prices[i - period + 1:i + 1])
            bb_upper[i] = sma[i] + (rolling_std * std_dev)
            bb_lower[i] = sma[i] - (rolling_std * std_dev)
        
        return bb_upper, sma, bb_lower

def test_final_features():
    """Test Step 12: All final features"""
    
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication(sys.argv)
    
    # Create window
    win = QtWidgets.QMainWindow()
    win.setWindowTitle("Step 12: Final Features - No Grid + Crosshair + OHLC + Indicators")
    win.resize(1600, 900)  # Larger window for all features
    
    # Create final features chart widget
    chart_widget = FinalFeaturesChartWidget()
    win.setCentralWidget(chart_widget)
    
    # Show window
    win.show()
    win.raise_()
    win.activateWindow()
    
    # Process events to ensure rendering
    for i in range(25):
        app.processEvents()
        QtCore.QThread.msleep(100)
    
    # Save screenshot
    save_widget_screenshot(win, "step12_final_features_result.png")
    
    print("\n=== STEP 12 FINAL FEATURES VERIFICATION ===")
    print("All requested features implemented:")
    print("1. ✓ Background gridlines REMOVED")
    print("2. ✓ Red crosshairs with yellow data box showing price/time")
    print("3. ✓ OHLC data display at top when hovering (DT, O, H, L, C)")
    print("4. ✓ Indicators plotting properly: SMA(20), EMA(12), Bollinger Bands")
    print("")
    print("Additional features:")
    print("  ✓ Y-axis auto-fits to visible price range")
    print("  ✓ Ctrl+wheel X-zoom, wheel X-pan")
    print("  ✓ Red/green candlesticks")
    print("  ✓ All axis labels visible")
    print("")
    print("Test interactions:")
    print("  - Move mouse over chart to see crosshairs and data")
    print("  - Hover over different bars to see OHLC data at top")
    print("  - Ctrl+scroll to zoom, regular scroll to pan")
    print("  - Notice NO background grid lines")
    print("  - See indicators plotted on chart")
    print("")
    print("Check step12_final_features_result.png for verification")
    
    return app, win

if __name__ == "__main__":
    app, win = test_final_features()
    
    # Keep open for extended testing
    QtCore.QTimer.singleShot(30000, app.quit)  # 30 seconds for testing
    app.exec_()